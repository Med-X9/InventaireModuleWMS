# Generated by Django 5.0.7 on 2025-01-13 19:00

from django.db import migrations
import random
import string
from django.utils import timezone
import uuid

def generate_unique_reference(apps, schema_editor):
    """Génère une référence unique avec retry"""
    JobDetailRessource = apps.get_model('inventory', 'JobDetailRessource')
    
    def generate_ref(prefix, max_attempts=10):
        for attempt in range(max_attempts):
            # Utiliser un timestamp plus précis avec microsecondes
            timestamp = timezone.now()
            timestamp_str = timestamp.strftime('%Y%m%d%H%M%S%f')[-8:]  # 8 derniers caractères
            
            # Générer un nombre aléatoire pour éviter les doublons
            random_suffix = str(random.randint(1000, 9999))
            
            # Créer la référence
            reference = f"{prefix}-{timestamp_str}-{random_suffix}"
            
            # S'assurer que la référence ne dépasse pas 20 caractères
            if len(reference) > 20:
                # Tronquer la référence si nécessaire
                reference = reference[:20]
            
            # Vérifier si la référence existe déjà
            if not JobDetailRessource.objects.filter(reference=reference).exists():
                return reference
        
        # Si on n'a pas trouvé de référence unique après max_attempts, utiliser un UUID
        return f"{prefix}-{str(uuid.uuid4())[:8].upper()}"
    
    return generate_ref

def fix_job_resource_references(apps, schema_editor):
    """Nettoie les références corrompues dans JobDetailRessource"""
    JobDetailRessource = apps.get_model('inventory', 'JobDetailRessource')
    
    print("=== Nettoyage des références corrompues JobDetailRessource ===")
    
    # 1. Trouver les enregistrements avec des références vides
    empty_refs = JobDetailRessource.objects.filter(reference__isnull=True)
    print(f"Enregistrements avec références vides: {empty_refs.count()}")
    
    # 2. Trouver les enregistrements avec des références vides (chaîne vide)
    empty_string_refs = JobDetailRessource.objects.filter(reference='')
    print(f"Enregistrements avec références vides (chaîne): {empty_string_refs.count()}")
    
    # 3. Trouver les enregistrements avec des références dupliquées
    from django.db.models import Count
    duplicates = JobDetailRessource.objects.values('reference').annotate(
        count=Count('reference')
    ).filter(count__gt=1, reference__isnull=False).exclude(reference='')
    
    duplicate_refs = [item['reference'] for item in duplicates]
    print(f"Références dupliquées trouvées: {len(duplicate_refs)}")
    
    generate_ref = generate_unique_reference(apps, schema_editor)
    total_fixed = 0
    
    # Corriger les références vides
    for record in empty_refs:
        record.reference = generate_ref('JDR')
        record.save()
        total_fixed += 1
        print(f"Corrigé enregistrement {record.id}: {record.reference}")
    
    # Corriger les chaînes vides
    for record in empty_string_refs:
        record.reference = generate_ref('JDR')
        record.save()
        total_fixed += 1
        print(f"Corrigé enregistrement {record.id}: {record.reference}")
    
    # Corriger les références dupliquées
    for ref in duplicate_refs:
        # Récupérer tous les enregistrements avec cette référence
        records_with_duplicate = JobDetailRessource.objects.filter(reference=ref)
        
        # Garder le premier et corriger les autres
        first_record = records_with_duplicate.first()
        other_records = records_with_duplicate.exclude(id=first_record.id)
        
        for record in other_records:
            record.reference = generate_ref('JDR')
            record.save()
            total_fixed += 1
            print(f"Corrigé enregistrement {record.id}: {record.reference} (dupliqué de {ref})")
    
    print(f"Total des références corrigées: {total_fixed}")

def reverse_fix_job_resource_references(apps, schema_editor):
    """Fonction de rollback (ne fait rien car c'est une correction de données)"""
    pass

class Migration(migrations.Migration):

    dependencies = [
        ('inventory', '0005_fix_inventory_references'),
    ]

    operations = [
        migrations.RunPython(fix_job_resource_references, reverse_fix_job_resource_references),
    ] 